---
output: github_document
bibliography: references.bib
link-citations: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)


```

# lolaR

<!-- badges: start -->
<!-- badges: end -->

lolaR is a package built to estimate the curvature in latent distance network models as described in @Hoff2002latent as well as test whether a network could have been generated by a latent space of constant curvature. We estimate the latent distances on a subset of the network using cliques.  We then exploit the fact that triangles allow for identification of the latent space provided we have a midpoint.  See @wilkins2022asymptotically for additional details

## Installation

You can install the development version of lolaR from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("SteveJWR/lolaR")
```





## Example

We highlight this application with two collaboration networks in Physics article co-authorship from @Leskovec2007GraphEvolution and available at @snapnets. We consider the problem of testing whether a latent space model has constant curvature. To do so we first consider two collaboration networks, one for Astrophysics and one for Condensed Matter Physics. 

```{r load packages and data}
library(lolaR)
library(ggplot2)
library(igraph)
library(Matrix)

load("data/Astro_adjacency_matrix.rda")
load("data/CondMat_adjacency_matrix.rda")

# Adjacency Matrix Names
#G.astro
#G.cm 
```


We next plot the largest connected components from the first 2000 indices. 

```{r define graph objects}

g.sub.astro <- igraph::graph_from_adjacency_matrix(G.astro[1:2000,1:2000], mode = "undirected")
g.sub.cm <- igraph::graph_from_adjacency_matrix(G.cm[1:2000,1:2000], mode = "undirected")


connected.idx.astro  <- which(components(g.sub.astro, mode = "strong")$membership == 4)
connected.idx.cm  <- which(components(g.sub.cm, mode = "strong")$membership == 35)


g.sub.astro <- igraph::graph_from_adjacency_matrix(G.astro[connected.idx.astro,connected.idx.astro], mode = "undirected")
g.sub.cm <- igraph::graph_from_adjacency_matrix(G.cm[connected.idx.cm,connected.idx.cm], mode = "undirected")

V(g.sub.astro)$name = NA
V(g.sub.cm)$name = NA
```

```{r Example Plot 1}
plot(g.sub.astro, vertex.size=4)
```

```{r Example Plot 2}
plot(g.sub.cm, vertex.size=4)
```

We first find a list of cliques of size $ 19 $ and $ 12 $ respectively.  This is in order to have a moderately large ($ 40-60 $) number of rows/columns in our distance matrix.


Since these networks are relatively sparse, we can compute the exact set of maximal cliques and partition them into non-overlapping sets. See the package for an approximate method of finding cliques. 
```{r Find Cliques Full}

cliques.astro = CliqueSearch(G.astro, min_clique_size = 19)
cliques.cm = CliqueSearch(G.cm, min_clique_size = 12)
```


Next using the set of cliques, we can estimate a distance matrix under the latent distance model without first choosing an embedding space.

```{r Estimate Distances, warning=FALSE}

D.astro <- EstimateD(G.astro, cliques.astro, verbose = T)
D.cliques <- EstimateD(G.cm, cliques.cm, verbose = T)

```


We first can search for the best midpoint and estimate the latent curvature for each model.


```{r Estimate Curvature, warning=FALSE}
kappa.astro <- EstimateCurvature(D.astro, verbose = T, d.yz.min = 1, d.yz.max = 4.5)
kappa.cm <- EstimateCurvature(D.cm, verbose = T, d.yz.min = 1, d.yz.max = 4.5)

```


From these distance matrices we are able to search for indices which approximately form a set $ y,z,m $ where $ m $ is the midpoint of $ y $ and $ z $, i.e. ($ d_{yz} = 2d_{ym} = 2d_{zm} $). After finding a set of $ R $ non-overlapping indices such approximately satisfying this midpoint equation $ \{y^{(r)},z^{(r)},m^{(r)}\}_{r = 1}^R $.

We would like to test the hypothesis
$$ H_0: \kappa(r) = \kappa \text{ for all } r \in \{1,2,\dots, R\} $$
Where $ \kappa(r) $ corresponds to the curvature at the corresponding point $ r $.


```{r Testing For Constant Curvature, warning=FALSE}

test.astro <- ConstantCurvatureTest(D.astro, num.midpoints = 3, d.yz.min = 1, d.yz.max = 4.5)
test.cm <- ConstantCurvatureTest(D.cm, num.midpoints = 3, d.yz.min = 1, d.yz.max = 4.5)

```

```{r}
med.vec.astro <- rep(0,3)
med.vec.cm <- rep(0,3)

for(k in seq(3)){
  med.vec.astro[k] = SoftThreshold(median(test.astro$estimates[test.astro$loc == k]), 10)
  med.vec.cm[k] = SoftThreshold(median(test.cm$estimates[test.cm$loc == k]),10)
}


```

```{r Plotting Curvature Estimated In Each Region Astrophysics}
library(ggplot2)


test.astro$scaled_estimates = SoftThreshold(test.astro$estimates, 10)
dat.astro <- data.frame(matrix(c(test.astro$loc, test.astro$scaled_estimates), ncol = 2))

names(dat.astro) = c("loc", "scaled_estimates")
ggplot(dat.astro, aes(y = scaled_estimates, x = loc)) +
  geom_jitter() +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  geom_vline(xintercept = 2.5, col = "red") +
  geom_vline(xintercept = 3.5, col = "red") +
  geom_segment(aes(x=0.5,xend=1.5,y=med.vec.astro[1],yend=med.vec.astro[1]), col = "blue") +
  geom_segment(aes(x=1.5,xend=2.5,y=med.vec.astro[2],yend=med.vec.astro[2]), col = "blue") +
  geom_segment(aes(x=2.5,xend=3.5,y=med.vec.astro[3],yend=med.vec.astro[3]), col = "blue") +
  ggtitle("Curvature Estimates Within Astrophysics Network") +
  ylab("Trimmed Curvature") +
  xlab("Midpoint Set")


```

```{r Plotting Curvature Estimated In Each Region CMP}



test.cm$scaled_estimates = SoftThreshold(test.cm$estimates, 10)
dat.cm <- data.frame(matrix(c(test.cm$loc, test.cm$scaled_estimates), ncol = 2))

names(dat.cm) = c("loc", "scaled_estimates")
ggplot(dat.cm, aes(y = scaled_estimates, x = loc)) +
  geom_jitter() +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  geom_vline(xintercept = 2.5, col = "red") +
  geom_vline(xintercept = 3.5, col = "red") +
  geom_segment(aes(x=0.5,xend=1.5,y=med.vec.cm[1],yend=med.vec.cm[1]), col = "blue") +
  geom_segment(aes(x=1.5,xend=2.5,y=med.vec.cm[2],yend=med.vec.cm[2]), col = "blue") +
  geom_segment(aes(x=2.5,xend=3.5,y=med.vec.cm[3],yend=med.vec.cm[3]), col = "blue") +
  ggtitle("Curvature Estimates Within CMP Network") +
  ylab("Trimmed Curvature") +
  xlab("Midpoint Set")


```

# References 




