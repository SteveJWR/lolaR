---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)


```

# lolaR

<!-- badges: start -->
<!-- badges: end -->

lolaR is a package built to estimate the curvature in latent distance network models as described in (?? include Hoff Citation ??) as well as test whether a network could have been generated by a latent space of constant curvature. We estimate the latent distances on a subset of the network using cliques.  We then exploit the fact that triangles allow for identification of the latent space provided we have a midpoint.  See (? Our ArXiv paper ?) for additional details

## Installation

You can install the development version of lolaR from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("SteveJWR/lolaR")
```

## Example

We highlight this application with an example from (? Jure Leskovec example ?). We consider the problem of testing whether a latent space model has constant curvature. To do so we first consider two citation networks, one for Astrophysics and one for Condensed Matter Physics. 

```{r example}
library(lolaR)

load("data/Astro_adjacency_matrix.rda")
load("data/CondMat_adjacency_matrix.rda")

# files shown
#G.astro
#G.cm 
```
We next plot the largest connected components from the first 1000 indices 

```{r example}
#library(igraph)
# files shown

g.sub.astro <- igraph::graph_from_adjacency_matrix(G.astro[1:2000,1:2000], mode = "undirected")
g.sub.cm <- igraph::graph_from_adjacency_matrix(G.cm[1:2000,1:2000], mode = "undirected")

# table(components(g.sub.astro, mode = "strong")$membership)
# table(components(g.sub.cm, mode = "strong")$membership)

connected.idx.astro  <- which(components(g.sub.astro, mode = "strong")$membership == 4)
connected.idx.cm  <- which(components(g.sub.cm, mode = "strong")$membership == 35)


g.sub.astro <- igraph::graph_from_adjacency_matrix(G.astro[connected.idx.astro,connected.idx.astro], mode = "undirected")
g.sub.cm <- igraph::graph_from_adjacency_matrix(G.cm[connected.idx.cm,connected.idx.cm], mode = "undirected")

V(g.sub.astro)$name = NA
V(g.sub.cm)$name = NA
```

```{r example}
plot(g.sub.astro, vertex.size=4)
```

```{r example}
plot(g.sub.cm, vertex.size=4)
```

We first find a list of cliques of size $19$ and $12$ respectively.  This is in order to have a moderately large ($40-60$) number of rows/columns in our distance matrix. 

We can either conduct an approximate search for cliques at least of size (k) 
```{r Find Cliques}
cliques.sample.astro = ClusterCliqueSearch(G.astro, min_clique_size = 19)
cliques.sample.cm = ClusterCliqueSearch(G.cm, min_clique_size = 12)
```

But since these networks are relatively sparse, we can compute the exact set of maximal cliques and partition them into non-overlapping sets. 
```{r Find Cliques Full}
g.astro <- igraph::graph_from_adjacency_matrix(G.astro, mode = "undirected")
g.cm <- igraph::graph_from_adjacency_matrix(G.cm, mode = "undirected")


cliques.astro = igraph::maximal.cliques(g.astro, min = 19)
cliques.cm = igraph::maximal.cliques(g.cm, min = 12)

cliques.astro <- CliquePartition(cliques.astro)
cliques.cm <- CliquePartition(cliques.cm)
```


Next using the set of cliques, we can estimate a distance matrix under the Latent distance model without first choosing an embedding space. 

```{r Estimate Distances, warning=FALSE}

D.astro <- EstimateD(G.astro, cliques.astro, verbose = T)
D.cliques <- EstimateD(G.cm, cliques.cm, verbose = T)

```


We first can search for the best midpoint and estimate the latent curvature for each model. 


```{r Estimate Curvature, warning=FALSE}
kappa.astro <- EstimateCurvature(D.astro, verbose = T, d.yz.min = 1, d.yz.max = 4.5)
kappa.cm <- EstimateCurvature(D.cm, verbose = T, d.yz.min = 1, d.yz.max = 4.5)

```


From these distance matrices we are able to search for indices which approximately form a set $y,z,m$ where $m$ is the midpoint of $y$ and $z$, i.e. ($d_{yz} = 2d_{ym} = 2d_{zm}$). After finding a set of $R$ non-overlapping indices such approximately satisfying this midpoint equation $\{y^{(r)},z^{(r)},m^{(r)}\}_{r = 1}^R$.  

We would like to test the hypothesis 
$$ H_0: \kappa(r) = \kappa \text{ for all } r \in \{1,2,\dots, R\}$$
Where $\kappa(r)$ corresponds to the curvature at the corresponding point $r$. 


```{r Testing For Constant Curvature, warning=FALSE}

test.astro <- ConstantCurvatureTest(D.astro, num.points = 3, d.yz.min = 1, d.yz.max = 4.5)
test.cm <- ConstantCurvatureTest(D.cm, num.points = 3, d.yz.min = 1, d.yz.max = 4.5)

```

```{r}
med.vec.astro <- rep(0,3)
med.vec.cm <- rep(0,3)

for(k in seq(3)){
  med.vec.astro[k] = SoftThreshold(median(test.astro$estimates[test.astro$loc == k]), 10)
  med.vec.cm[k] = SoftThreshold(median(test.cm$estimates[test.cm$loc == k]),10)
}


```

```{r Plotting Curvature Estimated In Each Region Astrophysics}
library(ggplot2)


test.astro$scaled_estimates = SoftThreshold(test.astro$estimates, 10)
dat.astro <- data.frame(matrix(c(test.astro$loc, test.astro$scaled_estimates), ncol = 2))

names(dat.astro) = c("loc", "scaled_estimates")
ggplot(dat.astro, aes(y = scaled_estimates, x = loc)) + 
  geom_jitter() + 
  geom_vline(xintercept = 0.5, col = "red") + 
  geom_vline(xintercept = 1.5, col = "red") + 
  geom_vline(xintercept = 2.5, col = "red") + 
  geom_vline(xintercept = 3.5, col = "red") + 
  geom_vline(xintercept = 4.5, col = "red") + 
  geom_vline(xintercept = 5.5, col = "red") + 
  geom_segment(aes(x=0.5,xend=1.5,y=med.vec.astro[1],yend=med.vec.astro[1]), col = "blue") + 
  geom_segment(aes(x=1.5,xend=2.5,y=med.vec.astro[2],yend=med.vec.astro[2]), col = "blue") + 
  geom_segment(aes(x=2.5,xend=3.5,y=med.vec.astro[3],yend=med.vec.astro[3]), col = "blue") + 
  ggtitle("Curvature Estimates Within Astrophysics Network") + 
  ylab("Trimmed Curvature") + 
  xlab("Midpoint Set")


```

```{r Plotting Curvature Estimated In Each Region Astrophysics}
library(ggplot2)


test.cm$scaled_estimates = SoftThreshold(test.cm$estimates, 10)
dat.cm <- data.frame(matrix(c(test.cm$loc, test.cm$scaled_estimates), ncol = 2))

names(dat.cm) = c("loc", "scaled_estimates")
ggplot(dat.cm, aes(y = scaled_estimates, x = loc)) + 
  geom_jitter() + 
  geom_vline(xintercept = 0.5, col = "red") + 
  geom_vline(xintercept = 1.5, col = "red") + 
  geom_vline(xintercept = 2.5, col = "red") + 
  geom_vline(xintercept = 3.5, col = "red") + 
  geom_vline(xintercept = 4.5, col = "red") + 
  geom_vline(xintercept = 5.5, col = "red") + 
  geom_segment(aes(x=0.5,xend=1.5,y=med.vec.cm[1],yend=med.vec.cm[1]), col = "blue") + 
  geom_segment(aes(x=1.5,xend=2.5,y=med.vec.cm[2],yend=med.vec.cm[2]), col = "blue") + 
  geom_segment(aes(x=2.5,xend=3.5,y=med.vec.cm[3],yend=med.vec.cm[3]), col = "blue") + 
  ggtitle("Curvature Estimates Within CMP Network") + 
  ylab("Trimmed Curvature") + 
  xlab("Midpoint Set")


```






